(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{22:function(a,r,t){var e=t(23);"string"==typeof e&&(e=[[a.i,e,""]]),e.locals&&(a.exports=e.locals);(0,t(1).default)("data-quickpaper-79d02186",e,!0)},23:function(a,r,t){(a.exports=t(0)(!1)).push([a.i,"",""])},33:function(a,r,t){"use strict";t.r(r);var e={};t(22);e.render=function(a){return a("div",{quickpaper:"","data-quickpaper-79d02186":""},[a("div",{class:"doc-view",id:"root-view","data-quickpaper-79d02186":""},[a("header",{id:"fixed-top","data-quickpaper-79d02186":""},["递归与分治策略"]),a("h1",{id:"fixed-dgdgl","data-quickpaper-79d02186":""},["递归的概念"]),a("p",{"data-quickpaper-79d02186":""},["直接或间接地调用自身的算法称为递归算法。"]),a("p",{"data-quickpaper-79d02186":""},["那什么是分治策略？"]),a("p",{"data-quickpaper-79d02186":""},["有时候，一个问题的规模比较大，也比较难，将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之，便是分治策略。"]),a("p",{class:"warn","data-quickpaper-79d02186":""},["比如对100个数进行排序要比对2个数进行排序要困难。"]),a("p",{"data-quickpaper-79d02186":""},["而分治往往产生许多原问题的较小规模的子问题，自然就导致递归算法。因此，分治与递归总是如影随形的出现（当然，有时候我们会出于一些原因的考虑想办法消除递归）。"]),a("h1",{id:"fixed-kspx","data-quickpaper-79d02186":""},["快速排序"]),a("p",{"data-quickpaper-79d02186":""},["其基本思想是，对于输入的子数组a[p:r]，按以下3个步骤进行排序："]),a("ul",{"data-quickpaper-79d02186":""},[a("li",{"data-quickpaper-79d02186":""},["（1）分解（divide）：以a[p]为基准元素将a[p:r]划分成3段a[p:q-1]、a[q]和a[q+1:r]，使得a[p:q-1]中任何元素小于等于a[q]，a[q+1:r]中任何元素大于等于a[q]。下标q在划分过程中确定。"]),a("li",{"data-quickpaper-79d02186":""},["（2）递归求解（conquer）：通过递归调用快速排序算法，分别对a[p:q-1]和a[q+1:r]进行排序。"]),a("li",{"data-quickpaper-79d02186":""},["（3）合并（merge）：由于对a[p:q-1]和a[q+1:r]的排序是就地进行的，所以在a[p:q-1]和a[q+1:r]都已拍好序后，不需要执行任何计算，a[p:r]就已排好序。"])]),a("p",{"data-quickpaper-79d02186":""},["基于这个思想，可实现快速排序的算法如下。"]),a("p",{"data-quickpaper-79d02186":""},["首先是用于分解的方法："]),a("pre",{"q-code":"","data-quickpaper-79d02186":""},["function partition(begin, end) {↵↵    // 把起点作为判断点↵    var left = begin, right = end + 1;↵↵    var compareData = dataArray[begin];↵    while (true) {↵↵        // left左边的值比判断点小↵        do {↵            left += 1;↵        } while (dataArray[left] < compareData && left < end);↵↵        // right右边的值比判断点小↵        do {↵            right -= 1;↵        } while (dataArray[right] > compareData);↵↵        // 如果交叉了，判断完毕↵        if (left >= right) break;↵↵        // 停止意味着需要交换left和right坐标对应的值↵        var temp = dataArray[left];↵        dataArray[left] = dataArray[right];↵        dataArray[right] = temp;↵↵    }↵↵    // 由于起点作为划分标准，和分界线的值进行交换↵    dataArray[begin] = dataArray[right];↵    dataArray[right] = compareData;↵↵    // 返回划分点的坐标↵    return right;↵}"]),a("p",{"data-quickpaper-79d02186":""},["然后，就是利用这个分解方法进行递归求解："]),a("pre",{"q-code":"","data-quickpaper-79d02186":""},["function quickSort(begin, end) {↵    if (begin < end) {↵        var splitIndex = partition(begin, end);↵        quickSort(begin, splitIndex - 1);↵        quickSort(splitIndex + 1, end);↵    }↵}"]),a("p",{"data-quickpaper-79d02186":""},["完整的代码请",a("a",{target:"_blank",class:"link",href:"https://github.com/hai2007/algorithm.js/blob/master/workbook/%E9%80%92%E5%BD%92%E4%B8%8E%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/no1-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.js","data-quickpaper-79d02186":""},["点击此处"]),"进行查看。"])])])};r.default=e}}]);