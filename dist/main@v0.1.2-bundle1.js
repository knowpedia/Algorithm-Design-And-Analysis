(window.webpackJsonp=window.webpackJsonp||[]).push([[1],{28:function(a,p,e){var i=e(29);"string"==typeof i&&(i=[[a.i,i,""]]),i.locals&&(a.exports=i.locals);(0,e(1).default)("data-quickpaper-34419a40",i,!0)},29:function(a,p,e){(a.exports=e(0)(!1)).push([a.i,"",""])},34:function(a,p,e){"use strict";e.r(p);var i={};e(28);i.render=function(a){return a("div",{quickpaper:"","data-quickpaper-34419a40":""},[a("div",{class:"doc-view",id:"root-view","data-quickpaper-34419a40":""},[a("header",{id:"fixed-top","data-quickpaper-34419a40":""},["回溯法"]),a("h1",{id:"fixed-sfsx","data-quickpaper-34419a40":""},["算法思想"]),a("p",{"data-quickpaper-34419a40":""},["说的直白点就是深度优先方式系统搜索问题的算法。"]),a("p",{"data-quickpaper-34419a40":""},["它在问题的解空间树中，按深度优先策略，从根结点出发搜索解空间树。算法搜索至解空间树的任一结点时，先判断该结点是否包含问题的解，如果肯定不包含，则跳过对以该结点为根的子树的搜索，逐层向其祖先结点回溯，否则，进入该子树，继续按深度优先策略搜索。"]),a("p",{"data-quickpaper-34419a40":""},["回溯法求问题的所有解时，要回溯到根，且根结点多所有子树都被搜索遍才结束，而在求一个解时，只有搜索到问题的一个解就可结束。"]),a("h1",{id:"fixed-01bbwt","data-quickpaper-34419a40":""},["0-1背包问题"]),a("p",{"data-quickpaper-34419a40":""},["给定n种物品和一背包，物品i的重量是w",a("sub",{"data-quickpaper-34419a40":""},["i"]),"，其价值为v",a("sub",{"data-quickpaper-34419a40":""},["i"]),"，背包的容量为C。问：应该如何选择装入背包的物品，使得装入背包中物品的总价值最大？"]),a("p",{"data-quickpaper-34419a40":""},["每个货物选择或者不选择可以标记为1和0，由此就可以构造出一棵二叉树，1是左树，0是右树，按照如下几条规则遍历："]),a("ul",{"data-quickpaper-34419a40":""},[a("li",{"data-quickpaper-34419a40":""},["（1）面对一个结点，先考虑左树是否可行，如果可以，进入当前结点的左树，如果不可以进入右树。"]),a("li",{"data-quickpaper-34419a40":""},["（2）遍历的时候如何到达了一个叶子结点，和当前取得的最大值进行比较，判断是否是更好的选择。"]),a("li",{"data-quickpaper-34419a40":""},["（3）到达一个叶子结点之后，就需要回溯，回溯的时候，如果发现是从右树回溯的，继续，直到从左树回溯或到达了根。"]),a("li",{"data-quickpaper-34419a40":""},["（4）回溯停止的时候，如果到达了根且上一次是从右树回溯的，遍历结束，否则，进入右树继续遍历。"])]),a("p",{"data-quickpaper-34419a40":""},["在遍历树图中，我们会发现，遍历子树和树是类似的，由此，就可以设计一个递归的算法实现："]),a("pre",{"q-code":"","data-quickpaper-34419a40":""},["function doCalc(deep,_volume){↵↵    // 先判断左树是否可行↵    if (_volume >= weight[index - 1]) {↵        var _sub_1_result = doCalc(index + 1, _volume - weight[index - 1]);↵    }↵↵    // 再计算右树的值↵    var _sub_0_result = doCalc(index + 1, _volume);↵↵    // 最后，选择其中最佳的↵    return _sub_1_result>_sub_0_result?'1':'0';↵}"]),a("p",{"data-quickpaper-34419a40":""},["完整的代码请",a("a",{target:"_blank",class:"link",href:"https://github.com/hai2007/algorithm.js/blob/master/workbook/%E5%9B%9E%E6%BA%AF%E6%B3%95/no1-0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98.js","data-quickpaper-34419a40":""},["点击此处"]),"进行查看。"]),a("h2",{id:"fixed-01bbwt-xcdg","data-quickpaper-34419a40":""},["消除递归"]),a("p",{"data-quickpaper-34419a40":""},["递归的写法虽然简单，但在空间上总是有点浪费，其实，可以借助一个数组来记录当前路径从而消除递归。"]),a("p",{"data-quickpaper-34419a40":""},["一个一维数组，值是0或1，分别表示对应层次选择的是左树还是右树，还有一个deep表示当前的遍历层次。进入树的时候，更新数组中对应的值，回溯的时候，通过查看值即可知道是从左树还是右树回溯的，而在到达叶子结点的时候，通过当前数组的记录，也可以构建出当前值的解。"]),a("p",{"data-quickpaper-34419a40":""},["完整的代码请",a("a",{target:"_blank",class:"link",href:"https://github.com/hai2007/algorithm.js/blob/master/workbook/%E5%9B%9E%E6%BA%AF%E6%B3%95/no2-0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%88%E6%B6%88%E9%99%A4%E9%80%92%E5%BD%92%EF%BC%89.js","data-quickpaper-34419a40":""},["点击此处"]),"进行查看。"])])])};p.default=i}}]);